// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: scd.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "Scd.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - ScdRoot

@implementation ScdRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - ScdRoot_FileDescriptor

static GPBFileDescriptor *ScdRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"com.webank.wedpr.scd.proto"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - CertificateSchema

@implementation CertificateSchema

@dynamic attributeNameArray, attributeNameArray_Count;

typedef struct CertificateSchema__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *attributeNameArray;
} CertificateSchema__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "attributeNameArray",
        .dataTypeSpecific.className = NULL,
        .number = CertificateSchema_FieldNumber_AttributeNameArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CertificateSchema__storage_, attributeNameArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CertificateSchema class]
                                     rootClass:[ScdRoot class]
                                          file:ScdRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CertificateSchema__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - StringToStringPair

@implementation StringToStringPair

@dynamic key;
@dynamic value;

typedef struct StringToStringPair__storage_ {
  uint32_t _has_storage_[1];
  NSString *key;
  NSString *value;
} StringToStringPair__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = StringToStringPair_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(StringToStringPair__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = StringToStringPair_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(StringToStringPair__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[StringToStringPair class]
                                     rootClass:[ScdRoot class]
                                          file:ScdRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(StringToStringPair__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CertificateTemplate

@implementation CertificateTemplate

@dynamic hasCertificateSchema, certificateSchema;
@dynamic templateCorrectnessProof;
@dynamic hasTemplatePublicKey, templatePublicKey;

typedef struct CertificateTemplate__storage_ {
  uint32_t _has_storage_[1];
  CertificateSchema *certificateSchema;
  NSString *templateCorrectnessProof;
  TemplatePublicKey *templatePublicKey;
} CertificateTemplate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "certificateSchema",
        .dataTypeSpecific.className = GPBStringifySymbol(CertificateSchema),
        .number = CertificateTemplate_FieldNumber_CertificateSchema,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CertificateTemplate__storage_, certificateSchema),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "templateCorrectnessProof",
        .dataTypeSpecific.className = NULL,
        .number = CertificateTemplate_FieldNumber_TemplateCorrectnessProof,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CertificateTemplate__storage_, templateCorrectnessProof),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "templatePublicKey",
        .dataTypeSpecific.className = GPBStringifySymbol(TemplatePublicKey),
        .number = CertificateTemplate_FieldNumber_TemplatePublicKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CertificateTemplate__storage_, templatePublicKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CertificateTemplate class]
                                     rootClass:[ScdRoot class]
                                          file:ScdRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CertificateTemplate__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TemplatePublicKey

@implementation TemplatePublicKey

@dynamic key;

typedef struct TemplatePublicKey__storage_ {
  uint32_t _has_storage_[1];
  NSString *key;
} TemplatePublicKey__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = TemplatePublicKey_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TemplatePublicKey__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TemplatePublicKey class]
                                     rootClass:[ScdRoot class]
                                          file:ScdRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TemplatePublicKey__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TemplatePrivateKey

@implementation TemplatePrivateKey

@dynamic key;

typedef struct TemplatePrivateKey__storage_ {
  uint32_t _has_storage_[1];
  NSString *key;
} TemplatePrivateKey__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = TemplatePrivateKey_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TemplatePrivateKey__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TemplatePrivateKey class]
                                     rootClass:[ScdRoot class]
                                          file:ScdRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TemplatePrivateKey__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AttributeDict

@implementation AttributeDict

@dynamic pairArray, pairArray_Count;

typedef struct AttributeDict__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *pairArray;
} AttributeDict__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pairArray",
        .dataTypeSpecific.className = GPBStringifySymbol(StringToStringPair),
        .number = AttributeDict_FieldNumber_PairArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AttributeDict__storage_, pairArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AttributeDict class]
                                     rootClass:[ScdRoot class]
                                          file:ScdRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AttributeDict__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlindedCertificateSecret

@implementation BlindedCertificateSecret

@dynamic blindedCertificateSecrets;
@dynamic blindedCertificateSecretsCorrectnessProof;

typedef struct BlindedCertificateSecret__storage_ {
  uint32_t _has_storage_[1];
  NSString *blindedCertificateSecrets;
  NSString *blindedCertificateSecretsCorrectnessProof;
} BlindedCertificateSecret__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "blindedCertificateSecrets",
        .dataTypeSpecific.className = NULL,
        .number = BlindedCertificateSecret_FieldNumber_BlindedCertificateSecrets,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlindedCertificateSecret__storage_, blindedCertificateSecrets),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "blindedCertificateSecretsCorrectnessProof",
        .dataTypeSpecific.className = NULL,
        .number = BlindedCertificateSecret_FieldNumber_BlindedCertificateSecretsCorrectnessProof,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BlindedCertificateSecret__storage_, blindedCertificateSecretsCorrectnessProof),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlindedCertificateSecret class]
                                     rootClass:[ScdRoot class]
                                          file:ScdRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlindedCertificateSecret__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CertificateSignature

@implementation CertificateSignature

@dynamic certificateSignature;
@dynamic signatureCorrectnessProof;

typedef struct CertificateSignature__storage_ {
  uint32_t _has_storage_[1];
  NSString *certificateSignature;
  NSString *signatureCorrectnessProof;
} CertificateSignature__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "certificateSignature",
        .dataTypeSpecific.className = NULL,
        .number = CertificateSignature_FieldNumber_CertificateSignature,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CertificateSignature__storage_, certificateSignature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "signatureCorrectnessProof",
        .dataTypeSpecific.className = NULL,
        .number = CertificateSignature_FieldNumber_SignatureCorrectnessProof,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CertificateSignature__storage_, signatureCorrectnessProof),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CertificateSignature class]
                                     rootClass:[ScdRoot class]
                                          file:ScdRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CertificateSignature__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Predicate

@implementation Predicate

@dynamic attributeName;
@dynamic predicateType;
@dynamic predicateValue;

typedef struct Predicate__storage_ {
  uint32_t _has_storage_[1];
  NSString *attributeName;
  NSString *predicateType;
  uint64_t predicateValue;
} Predicate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "attributeName",
        .dataTypeSpecific.className = NULL,
        .number = Predicate_FieldNumber_AttributeName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Predicate__storage_, attributeName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "predicateType",
        .dataTypeSpecific.className = NULL,
        .number = Predicate_FieldNumber_PredicateType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Predicate__storage_, predicateType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "predicateValue",
        .dataTypeSpecific.className = NULL,
        .number = Predicate_FieldNumber_PredicateValue,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Predicate__storage_, predicateValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Predicate class]
                                     rootClass:[ScdRoot class]
                                          file:ScdRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Predicate__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VerificationRuleSet

@implementation VerificationRuleSet

@dynamic revealedAttributeNameArray, revealedAttributeNameArray_Count;
@dynamic attributePredicateArray, attributePredicateArray_Count;

typedef struct VerificationRuleSet__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *revealedAttributeNameArray;
  NSMutableArray *attributePredicateArray;
} VerificationRuleSet__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "revealedAttributeNameArray",
        .dataTypeSpecific.className = NULL,
        .number = VerificationRuleSet_FieldNumber_RevealedAttributeNameArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VerificationRuleSet__storage_, revealedAttributeNameArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "attributePredicateArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Predicate),
        .number = VerificationRuleSet_FieldNumber_AttributePredicateArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VerificationRuleSet__storage_, attributePredicateArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VerificationRuleSet class]
                                     rootClass:[ScdRoot class]
                                          file:ScdRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VerificationRuleSet__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SignCertificateRequest

@implementation SignCertificateRequest

@dynamic hasCertificateAttributeDict, certificateAttributeDict;
@dynamic blindedCertificateSecrets;
@dynamic blindedCertificateSecretsCorrectnessProof;

typedef struct SignCertificateRequest__storage_ {
  uint32_t _has_storage_[1];
  AttributeDict *certificateAttributeDict;
  NSString *blindedCertificateSecrets;
  NSString *blindedCertificateSecretsCorrectnessProof;
} SignCertificateRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "certificateAttributeDict",
        .dataTypeSpecific.className = GPBStringifySymbol(AttributeDict),
        .number = SignCertificateRequest_FieldNumber_CertificateAttributeDict,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SignCertificateRequest__storage_, certificateAttributeDict),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "blindedCertificateSecrets",
        .dataTypeSpecific.className = NULL,
        .number = SignCertificateRequest_FieldNumber_BlindedCertificateSecrets,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SignCertificateRequest__storage_, blindedCertificateSecrets),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "blindedCertificateSecretsCorrectnessProof",
        .dataTypeSpecific.className = NULL,
        .number = SignCertificateRequest_FieldNumber_BlindedCertificateSecretsCorrectnessProof,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SignCertificateRequest__storage_, blindedCertificateSecretsCorrectnessProof),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SignCertificateRequest class]
                                     rootClass:[ScdRoot class]
                                          file:ScdRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SignCertificateRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VerifyRequest

@implementation VerifyRequest

@dynamic hasCertificateTemplate, certificateTemplate;
@dynamic verificationProof;
@dynamic verificationNonce;

typedef struct VerifyRequest__storage_ {
  uint32_t _has_storage_[1];
  CertificateTemplate *certificateTemplate;
  NSString *verificationProof;
  NSString *verificationNonce;
} VerifyRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "certificateTemplate",
        .dataTypeSpecific.className = GPBStringifySymbol(CertificateTemplate),
        .number = VerifyRequest_FieldNumber_CertificateTemplate,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VerifyRequest__storage_, certificateTemplate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "verificationProof",
        .dataTypeSpecific.className = NULL,
        .number = VerifyRequest_FieldNumber_VerificationProof,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VerifyRequest__storage_, verificationProof),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "verificationNonce",
        .dataTypeSpecific.className = NULL,
        .number = VerifyRequest_FieldNumber_VerificationNonce,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(VerifyRequest__storage_, verificationNonce),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VerifyRequest class]
                                     rootClass:[ScdRoot class]
                                          file:ScdRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VerifyRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ScdResult

@implementation ScdResult

@dynamic hasCertificateTemplate, certificateTemplate;
@dynamic hasTemplatePrivateKey, templatePrivateKey;
@dynamic issuerNonce;
@dynamic hasCertificateSignature, certificateSignature;
@dynamic userNonce;
@dynamic hasSignCertificateRequest, signCertificateRequest;
@dynamic userPrivateKey;
@dynamic certificateSecretsBlindingFactors;
@dynamic verificationNonce;
@dynamic hasVerifyRequest, verifyRequest;
@dynamic hasRevealedAttributeDict, revealedAttributeDict;
@dynamic boolResult;

typedef struct ScdResult__storage_ {
  uint32_t _has_storage_[1];
  CertificateTemplate *certificateTemplate;
  TemplatePrivateKey *templatePrivateKey;
  NSString *issuerNonce;
  CertificateSignature *certificateSignature;
  NSString *userNonce;
  SignCertificateRequest *signCertificateRequest;
  NSString *userPrivateKey;
  NSString *certificateSecretsBlindingFactors;
  NSString *verificationNonce;
  VerifyRequest *verifyRequest;
  AttributeDict *revealedAttributeDict;
} ScdResult__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "certificateTemplate",
        .dataTypeSpecific.className = GPBStringifySymbol(CertificateTemplate),
        .number = ScdResult_FieldNumber_CertificateTemplate,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ScdResult__storage_, certificateTemplate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "templatePrivateKey",
        .dataTypeSpecific.className = GPBStringifySymbol(TemplatePrivateKey),
        .number = ScdResult_FieldNumber_TemplatePrivateKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ScdResult__storage_, templatePrivateKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "issuerNonce",
        .dataTypeSpecific.className = NULL,
        .number = ScdResult_FieldNumber_IssuerNonce,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ScdResult__storage_, issuerNonce),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "certificateSignature",
        .dataTypeSpecific.className = GPBStringifySymbol(CertificateSignature),
        .number = ScdResult_FieldNumber_CertificateSignature,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ScdResult__storage_, certificateSignature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userNonce",
        .dataTypeSpecific.className = NULL,
        .number = ScdResult_FieldNumber_UserNonce,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ScdResult__storage_, userNonce),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "signCertificateRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(SignCertificateRequest),
        .number = ScdResult_FieldNumber_SignCertificateRequest,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ScdResult__storage_, signCertificateRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userPrivateKey",
        .dataTypeSpecific.className = NULL,
        .number = ScdResult_FieldNumber_UserPrivateKey,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ScdResult__storage_, userPrivateKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "certificateSecretsBlindingFactors",
        .dataTypeSpecific.className = NULL,
        .number = ScdResult_FieldNumber_CertificateSecretsBlindingFactors,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ScdResult__storage_, certificateSecretsBlindingFactors),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "verificationNonce",
        .dataTypeSpecific.className = NULL,
        .number = ScdResult_FieldNumber_VerificationNonce,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ScdResult__storage_, verificationNonce),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "verifyRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(VerifyRequest),
        .number = ScdResult_FieldNumber_VerifyRequest,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ScdResult__storage_, verifyRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "revealedAttributeDict",
        .dataTypeSpecific.className = GPBStringifySymbol(AttributeDict),
        .number = ScdResult_FieldNumber_RevealedAttributeDict,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(ScdResult__storage_, revealedAttributeDict),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "boolResult",
        .dataTypeSpecific.className = NULL,
        .number = ScdResult_FieldNumber_BoolResult,
        .hasIndex = 11,
        .offset = 12,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ScdResult class]
                                     rootClass:[ScdRoot class]
                                          file:ScdRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ScdResult__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
